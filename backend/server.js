const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
require('dotenv').config();

const config = require('./config/env');
const db = require('./config/database');

const app = express();

// Middlewares de seguran√ßa
app.use(helmet());

// Configura√ß√£o de CORS mais flex√≠vel para desenvolvimento
const defaultLocalHostPort = '5173'; // Porta que voc√™ mais usa
const localHostOriginRegex = /^http:\/\/localhost:\d+$/;

const corsOptions = {
  credentials: true,
  origin: function (origin, callback) {
    console.log(`[CORS] Requisi√ß√£o da origem: ${origin}`); // Log da origem
    console.log(`[CORS] Config.CORS_ORIGIN: ${config.CORS_ORIGIN}`); // Log da configura√ß√£o
    console.log(`[CORS] Teste da regex para localhost: ${localHostOriginRegex.test(origin)} (Origem: ${origin})`);

    let allowed = false;
    if (config.CORS_ORIGIN === '*') {
      allowed = true;
    } else if (!origin) { // requisi√ß√µes sem 'Origin' (ex: same-origin, server-to-server, ou algumas ferramentas)
      allowed = true;
    } else if (localHostOriginRegex.test(origin)) {
      allowed = true;
    } else if (origin === config.CORS_ORIGIN) {
      allowed = true;
    } else if (config.CORS_ORIGIN && typeof config.CORS_ORIGIN === 'string' && config.CORS_ORIGIN.includes(',')) {
      // Se CORS_ORIGIN for uma lista de URLs separadas por v√≠rgula
      if (config.CORS_ORIGIN.split(',').map(item => item.trim()).includes(origin)) {
        allowed = true;
      }
    }
    // Adicione um log final para o resultado da verifica√ß√£o
    console.log(`[CORS] A origem "${origin}" √© permitida? ${allowed}`);

    if (allowed) {
      // console.log(`[CORS] Origem permitida: ${origin}`); // Comentado pois o log acima j√° informa
      callback(null, true);
    } else {
      console.warn(`[CORS] Origem N√ÉO permitida: ${origin}. Verifique a vari√°vel de ambiente CORS_ORIGIN ou a configura√ß√£o do servidor.`);
      callback(new Error('N√£o permitido pelo CORS. Verifique a origem da requisi√ß√£o e a configura√ß√£o CORS_ORIGIN do servidor.'));
    }
  },
  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'X-CSRF-Token', 'Accept', 'Origin'], // Adicionando mais headers comuns
};

// Lidar com requisi√ß√µes OPTIONS globalmente ANTES de outras rotas
app.options('*', cors(corsOptions));

// Aplicar CORS para todas as outras requisi√ß√µes
app.use(cors(corsOptions));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: config.NODE_ENV === 'development' ? 1000 : 100, // 1000 requests em dev, 100 em produ√ß√£o
  message: {
    error: 'Muitas requisi√ß√µes deste IP, tente novamente em alguns minutos.',
    retryAfter: Math.round(15 * 60 * 1000 / 1000)
  }
});
app.use(limiter);

// Middlewares de parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Middleware de logging
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.path} - Origem: ${req.headers.origin}`);
  next();
});

// Importar rotas
const authRoutes = require('./routes/auth');
const ordersRoutes = require('./routes/orders');
const productsRoutes = require('./routes/products');
const deliverersRoutes = require('./routes/deliverers');
const customersRoutes = require('./routes/customers');
const couponsRoutes = require('./routes/coupons');
const dashboardRoutes = require('./routes/dashboard');
const expensesRoutes = require('./routes/expenses');
const reportsRoutes = require('./routes/reports');
const cashClosingRoutes = require('./routes/cash-closing');
const migrateRoutes = require('./routes/migrate');
const cacheAdminRoutes = require('./routes/cache-admin');
const configurationsRoutes = require('./routes/configurations');
const profitCalculatorRoutes = require('./routes/profit-calculator');
const ownerRoutes = require('./routes/owner');

// Registrar rotas
app.use('/api/auth', authRoutes);
app.use('/api/orders', ordersRoutes);
app.use('/api/products', productsRoutes);
app.use('/api/deliverers', deliverersRoutes);
app.use('/api/customers', customersRoutes);
app.use('/api/coupons', couponsRoutes);
app.use('/api/dashboard', dashboardRoutes);
app.use('/api/expenses', expensesRoutes);
app.use('/api/reports', reportsRoutes);
app.use('/api/cash-closing', cashClosingRoutes);
app.use('/api/migrate', migrateRoutes);
app.use('/api/cache-admin', cacheAdminRoutes);
app.use('/api/configurations', configurationsRoutes);
app.use('/api/profit-calculator', profitCalculatorRoutes);
app.use('/api/owner', ownerRoutes);


// Ignorar requisi√ß√µes para favicon.ico
app.get('/favicon.ico', (req, res) => res.status(204).end());

// Rota de health check
app.get('/api/health', async (req, res) => {
  try {
    await db.query('SELECT 1');
    res.json({ 
      status: 'OK', 
      timestamp: new Date().toISOString(),
      database: 'Connected' 
    });
  } catch (error) {
    res.status(500).json({ 
      status: 'ERROR', 
      timestamp: new Date().toISOString(),
      database: 'Disconnected',
      error: error.message 
    });
  }
});

// Middleware de tratamento de erros
app.use((error, req, res, next) => {
  console.error('Erro:', error);
  res.status(500).json({ 
    error: 'Erro interno do servidor',
    message: config.NODE_ENV === 'development' ? error.message : 'Algo deu errado'
  });
});

// Middleware para rotas n√£o encontradas
app.use('*', (req, res) => {
  res.status(404).json({ error: 'Rota n√£o encontrada' });
});

const PORT = config.PORT;

// Fun√ß√£o para executar migra√ß√£o de tipos de produto
async function runProductTypesMigration() {
  try {
    console.log('üîÑ Verificando e aplicando migra√ß√£o de tipos de produto...');
    
    // Verificar se a constraint j√° inclui 'borda'
    const checkResult = await db.query(`
      SELECT conname, pg_get_constraintdef(oid) as constraint_def
      FROM pg_constraint
      WHERE conrelid = 'produtos'::regclass AND conname = 'produtos_tipo_produto_check';
    `);
    
    if (checkResult.rows.length > 0) {
      const constraint = checkResult.rows[0].constraint_def;
      if (constraint.includes("'borda'")) {
        console.log('‚úÖ Constraint j√° inclui tipo "borda" - migra√ß√£o n√£o necess√°ria');
      } else {
        console.log('üìã Atualizando constraint para incluir tipo "borda"...');
        
        // Remover constraint existente
        await db.query(`
          ALTER TABLE produtos
          DROP CONSTRAINT IF EXISTS produtos_tipo_produto_check;
        `);
        
        // Adicionar nova constraint com 'borda'
        await db.query(`
          ALTER TABLE produtos
          ADD CONSTRAINT produtos_tipo_produto_check 
          CHECK (tipo_produto IN ('pizza', 'bebida', 'sobremesa', 'acompanhamento', 'outro', 'borda'));
        `);
        
        console.log('‚úÖ Migra√ß√£o de tipos de produto conclu√≠da com sucesso!');
      }
    }
    
    console.log('üí° Agora voc√™ pode cadastrar bordas de pizza no sistema!');
    
  } catch (error) {
    console.error('‚ùå Erro durante a migra√ß√£o de tipos de produto:', error.message);
    // N√£o parar o servidor por causa da migra√ß√£o
  }
}

// Fun√ß√£o para executar migra√ß√£o de taxa de entrega
async function runTaxaEntregaMigration() {
  try {
    console.log('üîÑ Verificando e aplicando migra√ß√£o de taxa de entrega...');
    
    // Verificar se a coluna taxa_entrega j√° existe
    const checkColumn = await db.query(`
      SELECT column_name 
      FROM information_schema.columns 
      WHERE table_name = 'pedidos' 
      AND column_name = 'taxa_entrega';
    `);
    
    if (checkColumn.rows.length === 0) {
      console.log('üìã Adicionando coluna taxa_entrega √† tabela pedidos...');
      
      await db.query(`
        ALTER TABLE pedidos 
        ADD COLUMN taxa_entrega NUMERIC(10,2) DEFAULT 0.00;
      `);
      
      await db.query(`
        COMMENT ON COLUMN pedidos.taxa_entrega IS 'Taxa de entrega aplicada ao pedido (apenas para delivery)';
      `);
      
      console.log('‚úÖ Migra√ß√£o de taxa de entrega conclu√≠da com sucesso!');
    } else {
      console.log('‚úÖ Coluna taxa_entrega j√° existe - migra√ß√£o n√£o necess√°ria');
    }

    // Verificar se a coluna entregador_nome j√° existe
    const checkEntregadorNome = await db.query(`
      SELECT column_name 
      FROM information_schema.columns 
      WHERE table_name = 'pedidos' 
      AND column_name = 'entregador_nome';
    `);
    
    if (checkEntregadorNome.rows.length === 0) {
      console.log('üìã Adicionando coluna entregador_nome √† tabela pedidos...');
      
      await db.query(`
        ALTER TABLE pedidos 
        ADD COLUMN entregador_nome VARCHAR(255) DEFAULT NULL;
      `);
      
      await db.query(`
        COMMENT ON COLUMN pedidos.entregador_nome IS 'Nome do entregador para exibi√ß√£o no cupom';
      `);
      
      console.log('‚úÖ Migra√ß√£o de entregador_nome conclu√≠da com sucesso!');
    } else {
      console.log('‚úÖ Coluna entregador_nome j√° existe - migra√ß√£o n√£o necess√°ria');
    }
    
  } catch (error) {
    console.error('‚ùå Erro durante a migra√ß√£o de taxa de entrega:', error.message);
    // N√£o parar o servidor por causa da migra√ß√£o
  }
}

// Fun√ß√£o para executar migra√ß√£o da tabela fechamento_caixa
async function runFechamentoCaixaMigration() {
  try {
    console.log('üîÑ Verificando e aplicando migra√ß√£o da tabela fechamento_caixa...');
    
    // Lista de colunas que precisam existir na tabela fechamento_caixa
    const requiredColumns = [
      { name: 'total_pedidos', type: 'INTEGER DEFAULT 0' },
      { name: 'total_vendas', type: 'NUMERIC(10,2) DEFAULT 0.00' },
      { name: 'total_despesas_extras', type: 'NUMERIC(10,2) DEFAULT 0.00' },
      { name: 'total_receitas_extras', type: 'NUMERIC(10,2) DEFAULT 0.00' },
      { name: 'total_descontos', type: 'NUMERIC(10,2) DEFAULT 0.00' },
      { name: 'total_impostos', type: 'NUMERIC(10,2) DEFAULT 0.00' },
      { name: 'total_taxas_entrega', type: 'NUMERIC(10,2) DEFAULT 0.00' },
      { name: 'saldo_final', type: 'NUMERIC(10,2) DEFAULT 0.00' },
      { name: 'vendas_por_metodo', type: 'JSONB DEFAULT \'{}\'::jsonb' }
    ];
    
    // Verificar quais colunas existem
    const existingColumns = await db.query(`
      SELECT column_name 
      FROM information_schema.columns 
      WHERE table_name = 'fechamento_caixa';
    `);
    
    const existingColumnNames = existingColumns.rows.map(row => row.column_name);
    
    // Adicionar colunas que n√£o existem
    for (const column of requiredColumns) {
      if (!existingColumnNames.includes(column.name)) {
        console.log(`üìã Adicionando coluna ${column.name} √† tabela fechamento_caixa...`);
        
        await db.query(`
          ALTER TABLE fechamento_caixa 
          ADD COLUMN ${column.name} ${column.type};
        `);
        
        console.log(`‚úÖ Coluna ${column.name} adicionada com sucesso!`);
      } else {
        console.log(`‚úÖ Coluna ${column.name} j√° existe`);
      }
    }
    
    console.log('‚úÖ Migra√ß√£o da tabela fechamento_caixa conclu√≠da com sucesso!');
    
  } catch (error) {
    console.error('‚ùå Erro durante a migra√ß√£o da tabela fechamento_caixa:', error.message);
    // N√£o parar o servidor por causa da migra√ß√£o
  }
}

// Fun√ß√£o para executar migra√ß√£o de m√∫ltiplos pagamentos
async function runMultiplePaymentsMigration() {
  try {
    console.log('üîÑ Verificando e aplicando migra√ß√£o de m√∫ltiplos pagamentos...');
    
    // Verificar se a tabela pagamentos_pedido j√° existe
    const checkTable = await db.query(`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'public' 
      AND table_name = 'pagamentos_pedido';
    `);
    
    if (checkTable.rows.length === 0) {
      console.log('üìã Criando tabela pagamentos_pedido...');
      
      await db.query(`
        CREATE TABLE pagamentos_pedido (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          pedido_id UUID NOT NULL REFERENCES pedidos(id) ON DELETE CASCADE,
          forma_pagamento VARCHAR(50) NOT NULL,
          valor NUMERIC(10,2) NOT NULL,
          observacoes TEXT,
          created_at TIMESTAMP DEFAULT NOW(),
          updated_at TIMESTAMP DEFAULT NOW()
        );
      `);
      
      await db.query(`
        CREATE INDEX idx_pagamentos_pedido_pedido_id ON pagamentos_pedido(pedido_id);
      `);
      
      await db.query(`
        COMMENT ON TABLE pagamentos_pedido IS 'M√∫ltiplas formas de pagamento por pedido';
        COMMENT ON COLUMN pagamentos_pedido.forma_pagamento IS 'Forma de pagamento: dinheiro, cartao, pix, etc';
        COMMENT ON COLUMN pagamentos_pedido.valor IS 'Valor pago nesta forma de pagamento';
      `);
      
      console.log('‚úÖ Tabela pagamentos_pedido criada com sucesso!');
    } else {
      console.log('‚úÖ Tabela pagamentos_pedido j√° existe');
    }
    
    // Verificar se precisa adicionar coluna para indicar m√∫ltiplos pagamentos
    const checkMultipleColumn = await db.query(`
      SELECT column_name 
      FROM information_schema.columns 
      WHERE table_name = 'pedidos' 
      AND column_name = 'multiplos_pagamentos';
    `);
    
    if (checkMultipleColumn.rows.length === 0) {
      console.log('üìã Adicionando coluna multiplos_pagamentos √† tabela pedidos...');
      
      await db.query(`
        ALTER TABLE pedidos 
        ADD COLUMN multiplos_pagamentos BOOLEAN DEFAULT FALSE;
      `);
      
      await db.query(`
        COMMENT ON COLUMN pedidos.multiplos_pagamentos IS 'Indica se o pedido usa m√∫ltiplas formas de pagamento';
      `);
      
      console.log('‚úÖ Coluna multiplos_pagamentos adicionada com sucesso!');
    } else {
      console.log('‚úÖ Coluna multiplos_pagamentos j√° existe');
    }
    
    console.log('‚úÖ Migra√ß√£o de m√∫ltiplos pagamentos conclu√≠da com sucesso!');
    
  } catch (error) {
    console.error('‚ùå Erro durante a migra√ß√£o de m√∫ltiplos pagamentos:', error.message);
    // N√£o parar o servidor por causa da migra√ß√£o
  }
}

// Fun√ß√£o para executar migra√ß√£o da tabela de configura√ß√µes
async function runConfigurationsMigration() {
  try {
    console.log('üîÑ Verificando e aplicando migra√ß√£o da tabela configuracoes...');
    
    // Verificar se a tabela configuracoes j√° existe
    const checkTable = await db.query(`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'public' 
      AND table_name = 'configuracoes';
    `);
    
    if (checkTable.rows.length === 0) {
      console.log('üìã Criando tabela configuracoes...');
      
      await db.query(`
        CREATE TABLE configuracoes (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          chave VARCHAR(100) UNIQUE NOT NULL,
          valor TEXT,
          descricao TEXT,
          tipo VARCHAR(50) DEFAULT 'texto',
          ativo BOOLEAN DEFAULT true,
          created_at TIMESTAMP DEFAULT NOW(),
          updated_at TIMESTAMP DEFAULT NOW()
        );
      `);
      
      await db.query(`
        CREATE INDEX idx_configuracoes_chave ON configuracoes(chave);
        CREATE INDEX idx_configuracoes_ativo ON configuracoes(ativo);
      `);
      
      await db.query(`
        COMMENT ON TABLE configuracoes IS 'Configura√ß√µes gerais do sistema (PIX, impressora, etc)';
        COMMENT ON COLUMN configuracoes.chave IS 'Chave √∫nica da configura√ß√£o';
        COMMENT ON COLUMN configuracoes.valor IS 'Valor da configura√ß√£o (pode ser texto, JSON, etc)';
        COMMENT ON COLUMN configuracoes.tipo IS 'Tipo da configura√ß√£o: texto, json, url, boolean, numero';
      `);
      
      // Inserir configura√ß√£o padr√£o do PIX
      await db.query(`
        INSERT INTO configuracoes (chave, valor, descricao, tipo) 
        VALUES (
          'pix_qr_code', 
          'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
          'QR Code PIX para pagamentos (base64 ou URL)',
          'texto'
        ),
        (
          'pix_chave',
          'pitstop.pizzaria@exemplo.com',
          'Chave PIX da pizzaria',
          'texto'
        ),
        (
          'empresa_nome',
          'PIT STOP PIZZARIA',
          'Nome da empresa para cupons',
          'texto'
        );
      `);
      
      console.log('‚úÖ Tabela configuracoes criada com configura√ß√µes padr√£o!');
    } else {
      console.log('‚úÖ Tabela configuracoes j√° existe');
      
      // Verificar se as configura√ß√µes padr√£o existem
      const existingConfigs = await db.query(`
        SELECT chave FROM configuracoes 
        WHERE chave IN ('pix_qr_code', 'pix_chave', 'empresa_nome')
      `);
      
      const existingKeys = existingConfigs.rows.map(row => row.chave);
      
      if (!existingKeys.includes('pix_qr_code')) {
        await db.query(`
          INSERT INTO configuracoes (chave, valor, descricao, tipo) 
          VALUES (
            'pix_qr_code', 
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==',
            'QR Code PIX para pagamentos (base64 ou URL)',
            'texto'
          );
        `);
        console.log('‚úÖ Configura√ß√£o pix_qr_code adicionada');
      }
      
      if (!existingKeys.includes('pix_chave')) {
        await db.query(`
          INSERT INTO configuracoes (chave, valor, descricao, tipo) 
          VALUES (
            'pix_chave',
            'pitstop.pizzaria@exemplo.com',
            'Chave PIX da pizzaria',
            'texto'
          );
        `);
        console.log('‚úÖ Configura√ß√£o pix_chave adicionada');
      }
      
      if (!existingKeys.includes('empresa_nome')) {
        await db.query(`
          INSERT INTO configuracoes (chave, valor, descricao, tipo) 
          VALUES (
            'empresa_nome',
            'PIT STOP PIZZARIA',
            'Nome da empresa para cupons',
            'texto'
          );
        `);
        console.log('‚úÖ Configura√ß√£o empresa_nome adicionada');
      }
    }
    
    console.log('‚úÖ Migra√ß√£o da tabela configuracoes conclu√≠da com sucesso!');
    
  } catch (error) {
    console.error('‚ùå Erro na migra√ß√£o da tabela configuracoes:', error.message);
    throw error;
  }
}

// Fun√ß√£o principal para executar todas as migra√ß√µes
async function runAllMigrations() {
  try {
    await runTaxaEntregaMigration();
    await runFechamentoCaixaMigration();
    await runMultiplePaymentsMigration();
    await runConfigurationsMigration(); // Adicionar nova migra√ß√£o
    console.log('‚úÖ Todas as migra√ß√µes executadas com sucesso!');
  } catch (error) {
    console.error('‚ùå Erro ao executar migra√ß√µes:', error);
    process.exit(1);
  }
}

app.listen(PORT, async () => {
  console.log(`üöÄ Servidor rodando na porta ${PORT}`);
  console.log(`üåê Environment: ${config.NODE_ENV}`);
  console.log(`üîó CORS habilitado para: ${config.CORS_ORIGIN}`);
  
  // Executar migra√ß√µes
  await runAllMigrations();
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('SIGTERM recebido, fechando servidor...');
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('SIGINT recebido, fechando servidor...');
  process.exit(0);
}); 